import axios from 'axios';
import * as cheerio from 'cheerio';
import fs from 'fs';
import path from 'path';

const CONFIG = {
	timeout: 30000,
	referer: 'https://toonstream.love/',
	maxRetries: 3,
};

const USER_AGENTS = [
	'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
	'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
	'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15',
	'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
];

const HOME_URL = 'https://toonstream.love/';
const DATA_DIR = path.resolve('data');
const POLL_INTERVAL_MS = 3000;

const seriesCache = new Map();
const seasonLocks = new Set();
const processedEpisodePaths = new Set();

function getUA() {
	return USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)];
}

function normalizeUrl(rawUrl, base = 'https://toonstream.love') {
	if (!rawUrl || /^javascript:/i.test(rawUrl)) return null;
	try {
		return new URL(rawUrl, base).href;
	} catch {
		return null;
	}
}

async function fetchHtmlWithRetry(url, retries = CONFIG.maxRetries) {
	let lastErr = null;
	for (let i = 1; i <= retries; i++) {
		try {
			const res = await axios.get(url, {
				timeout: CONFIG.timeout,
				headers: {
					'User-Agent': getUA(),
					Referer: CONFIG.referer,
					Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
				},
			});
			return String(res.data || '');
		} catch (err) {
			lastErr = err;
		}
	}
	throw new Error(`Failed to fetch ${url}: ${lastErr?.message || 'unknown error'}`);
}

function extractIframeEmbeds(episodeHtml) {
	const $ = cheerio.load(episodeHtml);
	const iframes = [];
	for (let i = 1; i <= 20; i++) {
		const container = $(`div#options-${i}`);
		if (!container.length) continue;
		container.find('iframe').each((_, el) => {
			const src = $(el).attr('src') || $(el).attr('data-src') || $(el).attr('data-lazy-src');
			const url = normalizeUrl(src);
			if (url) iframes.push({ option: i, url });
		});
	}
	$('iframe').each((_, el) => {
		const src = $(el).attr('src') || $(el).attr('data-src') || $(el).attr('data-lazy-src');
		const url = normalizeUrl(src);
		if (url && !iframes.some((x) => x.url === url)) iframes.push({ option: null, url });
	});
	return iframes;
}

async function resolveTrembedUrl(trembedUrl) {
	try {
		const html = await fetchHtmlWithRetry(trembedUrl);
		const $ = cheerio.load(html);
		const out = [];
		$('iframe').each((_, el) => {
			const src = $(el).attr('src') || $(el).attr('data-src') || $(el).attr('data-lazy-src');
			const url = normalizeUrl(src);
			if (url && !url.includes('toonstream.love')) out.push(url);
		});
		return out;
	} catch {
		return [];
	}
}

async function resolveEmbeds(embeds) {
	const resolved = [];
	await Promise.all(
		embeds.map(async (e) => {
			if (e.url.includes('trembed=')) {
				const real = await resolveTrembedUrl(e.url);
				if (real.length === 0) resolved.push({ option: e.option, url: e.url });
				else real.forEach((u) => resolved.push({ option: e.option, url: u }));
			} else if (e.url.includes('toonstream.love')) {
				// Sometimes wrapper without explicit trembed param
				const real = await resolveTrembedUrl(e.url);
				if (real.length === 0) resolved.push({ option: e.option, url: e.url });
				else real.forEach((u) => resolved.push({ option: e.option, url: u }));
			} else {
				resolved.push(e);
			}
		})
	);
	// Dedup
	const seen = new Set();
	return resolved.filter((r) => {
		const key = `${r.option ?? 'x'}|${r.url}`;
		if (seen.has(key)) return false;
		seen.add(key);
		return true;
	});
}

function describeElement(el) {
	if (!el || !el.length) return null;
	const node = el.get(0);
	if (!node) return null;
	const tag = node.tagName || node.name || 'element';
	const id = el.attr('id') ? `#${el.attr('id')}` : '';
	const cls = el.attr('class') ? `.${el.attr('class').trim().replace(/\s+/g, '.')}` : '';
	return `${tag}${id}${cls}`;
}

function extractHomepageEpisodeCards(html) {
	const $ = cheerio.load(html);
	const episodes = [];
	const seen = new Set();

	const matchRegex = /\/(episode|watch|anime|series)\//i;

	$('a[href]').each((index, el) => {
		const href = normalizeUrl($(el).attr('href'));
		if (!href || !matchRegex.test(href)) return;
		if (!href.startsWith('https://toonstream.love')) return;
		if (seen.has(href)) return;

		seen.add(href);

		episodes.push(collectAnchorInfo($, $(el)));
	});

	return episodes;
}

function collectAnchorInfo($, anchor) {
	let title = (anchor.attr('title') || anchor.text().trim()).replace(/\s+/g, ' ');
	const href = normalizeUrl(anchor.attr('href'));

	let thumb = null;
	const img = anchor.find('img').first();
	if (img.length) {
		thumb = normalizeUrl(img.attr('data-src') || img.attr('src'));
	}
	let card = anchor.closest('article, li, .post-item, .film-item');
	if (!thumb && card.length) {
		const cardImg = card.find('img').first();
		if (cardImg.length) thumb = normalizeUrl(cardImg.attr('data-src') || cardImg.attr('src'));
	}

	if (!card.length) card = anchor.parent();

	const contextNode = anchor.closest('section, div.widget, article, div');
	let context = null;
	if (contextNode.length) {
		const headerText = contextNode
			.find('header h1, header h2, header h3, h2.widget-title, h3.widget-title')
			.first()
			.text()
			.trim();
		context = headerText || contextNode.attr('id') || contextNode.attr('class') || null;
	}

	if (!title) title = context || 'Untitled';

	return {
		title,
		url: href,
		thumbnail: thumb,
		context: context || 'page',
		location: describeElement(card) || describeElement(anchor) || 'unknown',
	};
}

function parseEpisodeCode(url) {
	const match = url.match(/(\d+)x(\d+)/i);
	if (!match) return null;
	return {
		season: parseInt(match[1], 10),
		episode: parseInt(match[2], 10),
	};
}

function slugFromUrl(url) {
	try {
		const u = new URL(url);
		const parts = u.pathname.split('/').filter(Boolean);
		return parts[1] || parts[parts.length - 1] || 'item';
	} catch {
		return 'item';
	}
}

function sanitizeName(name) {
	return (name || 'untitled')
		.replace(/[<>:"/\\|?*]/g, '')
		.replace(/\s+/g, '-')
		.replace(/-+/g, '-')
		.replace(/^-|-$/g, '')
		.substring(0, 120) || 'untitled';
}

function ensureDataDir() {
	if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });
}

function ensureDir(dir) {
	if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

function extractCommonFields(html) {
	const $ = cheerio.load(html);
	const title =
		$('h1.entry-title').first().text().trim() ||
		$('meta[property="og:title"]').attr('content')?.trim() ||
		$('title').first().text().trim() ||
		'';

	const description =
		$('meta[property="og:description"]').attr('content')?.trim() ||
		$('div.entry-content p').first().text().trim() ||
		$('div.description p').first().text().trim() ||
		'';

	let releaseYear = null;
	const yearMatch = $('span.year, .year, [class*="year"]').first().text().match(/\d{4}/);
	if (yearMatch) releaseYear = parseInt(yearMatch[0], 10);

	const genres = [];
	$('a[rel="tag"], .genres a, [class*="genre"] a').each((_, el) => {
		const genre = $(el).text().trim();
		if (genre) genres.push(genre);
	});

	let thumbnail =
		normalizeUrl(
			$('div.post-thumbnail img').attr('src') ||
			$('div.post-thumbnail img').attr('data-src') ||
			$('div.post-thumbnail img').attr('data-lazy-src')
		);
	if (!thumbnail) thumbnail = normalizeUrl($('meta[property="og:image"]').attr('content'));
	if (!thumbnail) thumbnail = normalizeUrl($('.series-cover img').attr('src') || $('.series-cover img').attr('data-src'));

	let tmdbId = null;
	let tvdbId = null;
	$('meta[property*="tmdb"], [data-tmdb-id], [data-tmdb]').each((_, el) => {
		const id = $(el).attr('content') || $(el).attr('data-tmdb-id') || $(el).attr('data-tmdb');
		if (id && !tmdbId) {
			const match = String(id).match(/(\d+)/);
			if (match) tmdbId = parseInt(match[1], 10);
		}
	});
	$('meta[property*="tvdb"], [data-tvdb-id], [data-tvdb]').each((_, el) => {
		const id = $(el).attr('content') || $(el).attr('data-tvdb-id') || $(el).attr('data-tvdb');
		if (id && !tvdbId) {
			const match = String(id).match(/(\d+)/);
			if (match) tvdbId = parseInt(match[1], 10);
		}
	});

	const languages = [];
	$('[class*="language"], [class*="lang"], .language, .lang').each((_, el) => {
		const lang = $(el).text().trim();
		if (lang && !languages.includes(lang)) languages.push(lang);
	});

	return {
		title: title.replace(/\s+/g, ' '),
		description: description.replace(/\s+/g, ' '),
		release_year: releaseYear,
		genres,
		thumbnail,
		tmdb_id: tmdbId,
		tvdb_id: tvdbId,
		languages,
	};
}

function extractEpisodeMainPoster(episodeHtml) {
	const $ = cheerio.load(episodeHtml);
	let poster = normalizeUrl(
		$('div.video-options img').attr('src') ||
		$('div.video-options img').attr('data-src') ||
		$('div.video-options img').attr('data-lazy-src')
	);
	if (!poster) {
		poster = normalizeUrl(
			$('div.post-thumbnail img').attr('src') ||
			$('div.post-thumbnail img').attr('data-src') ||
			$('meta[property="og:image"]').attr('content')
		);
	}
	return poster;
}

async function fetchEpisodeContext(episodeUrl) {
	const episodeHtml = await fetchHtmlWithRetry(episodeUrl);
	const $ = cheerio.load(episodeHtml);
	let seriesAnchor =
		$('nav.breadcrumb a[href*="/series/"]').last();
	if (!seriesAnchor.length) {
		seriesAnchor = $('div.breadcrumb a[href*="/series/"]').last();
	}
	if (!seriesAnchor.length) {
		seriesAnchor = $('.entry-meta a[href*="/series/"]').first();
	}
	let seriesUrl = normalizeUrl(seriesAnchor.attr('href'));
	let seriesTitle = seriesAnchor.text().trim() || null;
	if (!seriesUrl) {
		const fallback = deriveSeriesUrlFromEpisode(episodeUrl);
		seriesUrl = fallback;
	}
	if (!seriesTitle) {
		seriesTitle = $('meta[property="og:series"]').attr('content')?.trim() || null;
		if (!seriesTitle) {
			seriesTitle = $('title').text().split('|')[0].trim() || null;
		}
	}
	return { episodeHtml, seriesUrl, seriesTitle };
}

async function ensureSeriesContext(seriesUrl, fallbackTitle = null) {
	if (!seriesUrl) throw new Error('Series URL not found for episode');
	if (seriesCache.has(seriesUrl)) return seriesCache.get(seriesUrl);

	const seriesHtml = await fetchHtmlWithRetry(seriesUrl);
	const common = extractCommonFields(seriesHtml);
	if (!common.title && fallbackTitle) common.title = fallbackTitle;
	if (!common.title) common.title = slugFromUrl(seriesUrl).replace(/-/g, ' ');
	const postId = extractPostId(seriesHtml);
	if (!postId) throw new Error('Series post ID not found');

	const baseName = sanitizeName(common.title || fallbackTitle || slugFromUrl(seriesUrl));
	const seriesDir = path.join(DATA_DIR, baseName);
	ensureDir(seriesDir);

	const seriesMetaPath = path.join(seriesDir, 'series.json');
	if (!fs.existsSync(seriesMetaPath)) {
		const payload = {
			...common,
			url: seriesUrl,
			fetchedAt: new Date().toISOString(),
		};
		fs.writeFileSync(seriesMetaPath, JSON.stringify(payload, null, 2), 'utf-8');
		console.log(`   üíæ Saved metadata -> ${path.relative(process.cwd(), seriesMetaPath)}`);
	}

	const ctx = { seriesUrl, title: common.title, postId, baseName, seriesDir, common };
	seriesCache.set(seriesUrl, ctx);
	return ctx;
}

function extractPostId(seriesHtml) {
	const $ = cheerio.load(seriesHtml);
	const candidates = [];

	$('input#post_id, input#postId, input[name="post_id"], input[name="post"], [data-post-id], [data-post]').each((_, el) => {
		const attrs = [
			$(el).attr('value'),
			$(el).attr('data-post-id'),
			$(el).attr('data-post'),
			$(el).attr('data-id'),
		];
		for (const attr of attrs) {
			if (attr && /^\d+$/.test(attr.trim())) {
				candidates.push(parseInt(attr.trim(), 10));
			}
		}
	});

	const bodyClass = $('body').attr('class') || '';
	const bodyMatch = bodyClass.match(/postid-(\d+)/);
	if (bodyMatch) candidates.push(parseInt(bodyMatch[1], 10));

	if (candidates.length > 0) return candidates[0];

	const html = $.html();
	const regexes = [
		/post[_-]?id\s*[:=]\s*"?(\d+)"?/i,
		/"post"\s*:\s*"?(\d+)"?/i,
		/"post_id"\s*:\s*"?(\d+)"?/i,
		/\bpost\s*=\s*(\d+)/i,
		/postID\s*=\s*['"](\d+)['"]/i,
		/var\s+postId\s*=\s*(\d+)/i,
	];
	for (const regex of regexes) {
		const match = html.match(regex);
		if (match && match[1]) return parseInt(match[1], 10);
	}
	return null;
}

async function main() {
	const args = process.argv.slice(2);
	const watchMode = args.includes('--watch');
	const printAll = args.includes('--all');
	const saveMode = args.includes('--save');
	let url = args.find((arg) => !arg.startsWith('--'));

	if (watchMode) {
		startWatcher();
		return;
	}

	if (!url) {
		url = HOME_URL;
	}
	console.log(`üîé Fetching: ${url}`);
	const html = await fetchHtmlWithRetry(url);

	// If not an episode URL, list homepage episode cards
	if (!/\/episode\//.test(url)) {
		const eps = filterRelevantHomepageEntries(extractHomepageEpisodeCards(html));
		console.log(`üß© Found ${eps.length} item(s) on page`);
		const list = printAll ? eps : eps.slice(0, 10);
		list.forEach((e, i) => {
			console.log(
				`${String(i + 1).padStart(2, '0')}. ${e.title} -> ${e.url}${e.thumbnail ? ` [thumb: ${e.thumbnail}]` : ''} (context: ${e.context}; location: ${e.location})`
			);
		});
		if (!printAll && eps.length > list.length) {
			console.log(`‚Ä¶ ${eps.length - list.length} more item(s) hidden. Run with --all to show everything.`);
		}
		return;
	}

	if (saveMode) {
		ensureDataDir();
		await handleEpisodeCard({ url }, { verbose: true });
		return;
	}

	// Episode page: extract and resolve players
	const raw = extractIframeEmbeds(html);
	console.log(`üß© Found ${raw.length} iframe(s) (before resolve)`);
	const resolved = await resolveEmbeds(raw);
	console.log(`\nüé¨ Video Sources:`);
	resolved.forEach((r) => {
		console.log(` - option=${r.option ?? 'n/a'} -> ${r.url}`);
	});
}

main().catch((e) => {
	console.error('‚ùå Error:', e.message);
	process.exit(1);
});

async function fetchSeasonEpisodesViaAjax(postId, seasonNumber, refererUrl = HOME_URL, retries = CONFIG.maxRetries) {
	let lastErr = null;
	for (let attempt = 1; attempt <= retries; attempt++) {
		try {
			const payload = new URLSearchParams();
			payload.append('action', 'action_select_season');
			payload.append('season', String(seasonNumber));
			payload.append('post', String(postId));

			const res = await axios.post('https://toonstream.love/wp-admin/admin-ajax.php', payload.toString(), {
				timeout: CONFIG.timeout,
				headers: {
					'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
					'User-Agent': getUA(),
					Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
					Referer: refererUrl,
					Origin: 'https://toonstream.love',
					'X-Requested-With': 'XMLHttpRequest',
				},
			});

			let html = res?.data;
			if (html == null) throw new Error('Empty season response');
			if (typeof html === 'object') {
				if (typeof html.data === 'string') html = html.data;
				else if (typeof html.html === 'string') html = html.html;
				else html = JSON.stringify(html);
			}
			html = String(html);
			if (!html.trim()) throw new Error('Season response empty');
			return html;
		} catch (err) {
			lastErr = err;
			if (attempt < retries) await delay(CONFIG.retryDelay);
		}
	}
	throw new Error(`Season AJAX failed after ${retries} attempts: ${lastErr?.message || 'unknown error'}`);
}

function extractEpisodesFromSeason(seasonHtml) {
	const $ = cheerio.load(seasonHtml);
	const episodes = [];
	const seen = new Set();

	$('#episode_by_temp a, ul#episode_by_temp li article a').each((_, el) => {
		const href = normalizeUrl($(el).attr('href'));
		if (!href || !href.includes('/episode/')) return;
		if (seen.has(href)) return;
		seen.add(href);
		const title = ($(el).text().trim() || $(el).find('.entry-title').text().trim() || '').replace(/\s+/g, ' ');
		const img =
			$(el).find('img[loading="lazy"]').attr('data-src') ||
			$(el).find('img').attr('data-src') ||
			$(el).find('img').attr('data-lazy-src') ||
			$(el).find('img').attr('src') ||
			null;
		episodes.push({ url: href, title, image: normalizeUrl(img) });
	});

	if (episodes.length === 0) {
		$('a[href*="/episode/"]').each((index, el) => {
			const href = normalizeUrl($(el).attr('href'));
			if (!href || seen.has(href)) return;
			seen.add(href);
			let title = $(el).text().trim();
			if (!title) title = $(el).attr('title')?.trim() || `Episode ${index + 1}`;
			let img =
				$(el).find('img').attr('data-src') ||
				$(el).find('img').attr('src') ||
				$(el).closest('li, article').find('img').attr('data-src') ||
				$(el).closest('li, article').find('img').attr('src') ||
				null;
			episodes.push({ url: href, title, image: normalizeUrl(img) });
		});
	}

	return episodes;
}

function delay(ms) {
	return new Promise((resolve) => setTimeout(resolve, ms));
}

function episodeFilePath(seriesCtx, seasonNumber, episodeNumber) {
	const seasonDir = path.join(seriesCtx.seriesDir, `season-${seasonNumber}`);
	return { seasonDir, filePath: path.join(seasonDir, `episode-${episodeNumber}.json`) };
}

function episodeExists(seriesCtx, seasonNumber, episodeNumber) {
	const { filePath } = episodeFilePath(seriesCtx, seasonNumber, episodeNumber);
	return fs.existsSync(filePath);
}

function buildEpisodePayload(seriesCtx, seasonNumber, episodeNumber, episodeData, fallbackImage) {
	return {
		series: seriesCtx.common.title || seriesCtx.title || null,
		thumbnail: seriesCtx.common.thumbnail || null,
		season: seasonNumber,
		episode: episodeNumber,
		episode_title: episodeData.title || null,
		episode_main_poster: episodeData.mainPoster || null,
		episode_card_thumbnail: fallbackImage || null,
		episode_list_thumbnail: fallbackImage || null,
		video_player_thumbnail: episodeData.videoPoster || null,
		servers: episodeData.embeds.map((e) => ({ option: e.option, real_video: e.url || null })),
	};
}

function saveEpisodeToDisk(seriesCtx, seasonNumber, episodeNumber, payload) {
	const { seasonDir, filePath } = episodeFilePath(seriesCtx, seasonNumber, episodeNumber);
	ensureDir(seasonDir);
	fs.writeFileSync(filePath, JSON.stringify(payload, null, 2), 'utf-8');
	processedEpisodePaths.add(filePath);
	console.log(`      üíæ Saved ${path.relative(process.cwd(), filePath)}`);
}

async function fetchEpisodeDetailsForSaving(episodeUrl) {
	const html = await fetchHtmlWithRetry(episodeUrl);
	const $ = cheerio.load(html);
	const title =
		$('meta[property="og:title"]').attr('content')?.trim() ||
		$('h1.entry-title').first().text().trim() ||
		$('title').first().text().trim() ||
		'Episode';

	const mainPoster = extractEpisodeMainPoster(html);
	const rawEmbeds = extractIframeEmbeds(html);
	const resolvedEmbeds = await resolveEmbeds(rawEmbeds);

	return {
		title,
		mainPoster,
		embeds: resolvedEmbeds,
		videoPoster: null,
	};
}

async function fetchAndStoreSeason(seriesCtx, seasonNumber) {
	const lockKey = `${seriesCtx.seriesUrl}|${seasonNumber}`;
	if (seasonLocks.has(lockKey)) return;
	seasonLocks.add(lockKey);
	try {
		console.log(`   üîÑ Checking Season ${seasonNumber} for missing episodes...`);
		const seasonHtml = await fetchSeasonEpisodesViaAjax(seriesCtx.postId, seasonNumber, seriesCtx.seriesUrl);
		const episodes = extractEpisodesFromSeason(seasonHtml);
		if (episodes.length === 0) {
			console.log(`   ‚ö†Ô∏è Season ${seasonNumber} returned no episodes via AJAX.`);
			return;
		}
		for (let index = 0; index < episodes.length; index++) {
			const ep = episodes[index];
			const parsed = parseEpisodeCode(ep.url);
			const episodeNumber = parsed?.episode ?? index + 1;
			const seasonInUrl = parsed?.season ?? seasonNumber;
			if (seasonInUrl !== seasonNumber) continue;
			if (episodeExists(seriesCtx, seasonNumber, episodeNumber)) continue;

			console.log(`      ‚è≥ Fetching S${seasonNumber}E${episodeNumber}: ${ep.title || ep.url}`);
			const details = await fetchEpisodeDetailsForSaving(ep.url);
			const payload = buildEpisodePayload(seriesCtx, seasonNumber, episodeNumber, details, ep.image || null);
			saveEpisodeToDisk(seriesCtx, seasonNumber, episodeNumber, payload);
		}
	} catch (err) {
		console.log(`   ‚ö†Ô∏è Failed to update Season ${seasonNumber}: ${err.message}`);
	} finally {
		seasonLocks.delete(lockKey);
	}
}

async function handleEpisodeCard(entry, { verbose = true } = {}) {
	const code = parseEpisodeCode(entry.url);
	if (!code) return;

	try {
		const { seriesUrl, seriesTitle } = await fetchEpisodeContext(entry.url);
		if (!seriesUrl) {
			if (verbose) console.log(`‚ö†Ô∏è Series URL not found for ${entry.url}`);
			return;
		}
		const seriesCtx = await ensureSeriesContext(seriesUrl, seriesTitle);
		const { filePath } = episodeFilePath(seriesCtx, code.season, code.episode);
		if (fs.existsSync(filePath)) {
			if (verbose) console.log(`‚úÖ Already saved S${code.season}E${code.episode} -> ${path.relative(process.cwd(), filePath)}`);
			return;
		}

		console.log(`üì• Fetching new episode: ${seriesCtx.title} S${code.season}E${code.episode}`);
		await fetchAndStoreSeason(seriesCtx, code.season);
	} catch (err) {
		console.log(`‚ö†Ô∏è Failed to process ${entry.url}: ${err.message}`);
	}
}

async function scanHomepageForWatcher() {
	const html = await fetchHtmlWithRetry(HOME_URL);
	const episodes = filterRelevantHomepageEntries(extractHomepageEpisodeCards(html)).slice(0, 30);
	if (episodes.length === 0) {
		console.log('‚ÑπÔ∏è No matching episode cards found in target widget.');
	}
	for (const entry of episodes) {
		await handleEpisodeCard(entry);
	}
}

function startWatcher() {
	ensureDataDir();
	console.log('üöÄ Episode watcher started (polling every 3 seconds)...');
	let running = false;
	const tick = async () => {
		if (running) return;
		running = true;
		try {
			await scanHomepageForWatcher();
		} catch (err) {
			console.log(`‚ö†Ô∏è Watcher tick failed: ${err.message}`);
		} finally {
			running = false;
		}
	};
	tick();
	setInterval(tick, POLL_INTERVAL_MS);
}

function filterRelevantHomepageEntries(entries) {
	return entries.filter((e) => e.location && e.location.includes('article.post.dfx.fcl.episodes.fa-play-circle'));
}

function deriveSeriesUrlFromEpisode(episodeUrl) {
	try {
		const u = new URL(episodeUrl);
		const parts = u.pathname.split('/').filter(Boolean);
		const episodeSlug = parts[1] || parts[parts.length - 1] || '';
		if (!episodeSlug) return null;
		const baseSlug = episodeSlug.replace(/-\d+x\d+$/i, '') || episodeSlug;
		return `${HOME_URL}series/${baseSlug}/`;
	} catch {
		return null;
	}
}
